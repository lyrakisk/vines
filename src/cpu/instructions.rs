use crate::cpu::addressing_modes::*;
use crate::cpu::*;
use once_cell::sync::Lazy;

use super::mappers::basic_mapper::BasicMapper;
use super::mappers::test_mapper::TestMapper;

#[derive(Clone, Copy)]
pub struct Instruction {
    pub opcode: u8,
    pub name: &'static str,
    pub bytes: u8,
    pub addressing_mode: AddressingModes,
    pub cycles: u8,
}

pub struct InstructionResult {
    pub executed_cycles: u8,
}

type InstructionHandler<M> = fn(&Instruction, &mut CPU<M>) -> InstructionResult;

impl Instruction {
    pub fn execute<M: Memory + 'static>(&self, cpu: &mut CPU<M>) -> InstructionResult {
        if std::any::TypeId::of::<M>() == std::any::TypeId::of::<BasicMapper>() {
            // SAFETY: we just checked M == BasicMapper
            let cpu = unsafe { &mut *(cpu as *mut CPU<M> as *mut CPU<BasicMapper>) };
            INSTRUCTIONS.get_handler(self.opcode).unwrap()(self, cpu)
        } else if std::any::TypeId::of::<M>() == std::any::TypeId::of::<TestMapper>() {
            // SAFETY: we just checked M == TestMapper
            let cpu = unsafe { &mut *(cpu as *mut CPU<M> as *mut CPU<TestMapper>) };
            INSTRUCTIONS_TEST.get_handler(self.opcode).unwrap()(self, cpu)
        } else {
            panic!("Unsupported mapper type");
        }
    }
}

#[rustfmt::skip]
// TODO: When more mappers are added, this should be generated by a macro
pub static INSTRUCTIONS: Lazy<InstructionMap<BasicMapper>> = Lazy::new(|| {
    vec![
        (Instruction {opcode: 0x69, name: "ADC", bytes: 2, addressing_mode: AddressingModes::Immediate, cycles: 2}, adc::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x65, name: "ADC", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, adc::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x75, name: "ADC", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 4}, adc::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x6D, name: "ADC", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, adc::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x7D, name: "ADC", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 4}, adc::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x79, name: "ADC", bytes: 3, addressing_mode: AddressingModes::AbsoluteY, cycles: 4}, adc::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x61, name: "ADC", bytes: 2, addressing_mode: AddressingModes::IndexedIndirectX, cycles: 6}, adc::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x71, name: "ADC", bytes: 2, addressing_mode: AddressingModes::IndirectIndexedY, cycles: 5}, and::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x29, name: "AND", bytes: 2, addressing_mode: AddressingModes::Immediate, cycles: 2}, and::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x25, name: "AND", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, and::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x35, name: "AND", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 4}, and::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x2D, name: "AND", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, and::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x3D, name: "AND", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 4}, and::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x39, name: "AND", bytes: 3, addressing_mode: AddressingModes::AbsoluteY, cycles: 4}, and::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x21, name: "AND", bytes: 2, addressing_mode: AddressingModes::IndexedIndirectX, cycles: 6}, and::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x31, name: "AND", bytes: 2, addressing_mode: AddressingModes::IndirectIndexedY, cycles: 5}, and::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x0A, name: "ASL", bytes: 1, addressing_mode: AddressingModes::Accumulator, cycles: 2}, asl::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x06, name: "ASL", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 5}, asl::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x16, name: "ASL", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 6}, asl::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x0E, name: "ASL", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 6}, asl::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x1E, name: "ASL", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 7}, asl::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x90, name: "BCC", bytes: 2, addressing_mode: AddressingModes::Relative, cycles: 2}, bcc::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xB0, name: "BCS", bytes: 2, addressing_mode: AddressingModes::Relative, cycles: 2}, bcs::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xF0, name: "BEQ", bytes: 2, addressing_mode: AddressingModes::Relative, cycles: 2}, beq::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x24, name: "BIT", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, bit::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x2C, name: "BIT", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, bit::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x30, name: "BMI", bytes: 2, addressing_mode: AddressingModes::Relative, cycles: 2}, bmi::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xD0, name: "BNE", bytes: 2, addressing_mode: AddressingModes::Relative, cycles: 2}, bne::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x10, name: "BPL", bytes: 2, addressing_mode: AddressingModes::Relative, cycles: 2}, bpl::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x00, name: "BRK", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 7}, brk::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x50, name: "BVC", bytes: 2, addressing_mode: AddressingModes::Relative, cycles: 2}, bvc::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x70, name: "BVS", bytes: 2, addressing_mode: AddressingModes::Relative, cycles: 2}, bvs::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x18, name: "CLC", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, clc::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xD8, name: "CLD", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, cld::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x58, name: "CLI", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, cli::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xB8, name: "CLV", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, clv::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xC9, name: "CMP", bytes: 2, addressing_mode: AddressingModes::Immediate, cycles: 2}, cmp::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xC5, name: "CMP", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, cmp::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xD5, name: "CMP", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 4}, cmp::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xCD, name: "CMP", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, cmp::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xDD, name: "CMP", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 4}, cmp::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xD9, name: "CMP", bytes: 3, addressing_mode: AddressingModes::AbsoluteY, cycles: 4}, cmp::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xC1, name: "CMP", bytes: 2, addressing_mode: AddressingModes::IndexedIndirectX, cycles: 6}, cmp::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xD1, name: "CMP", bytes: 2, addressing_mode: AddressingModes::IndirectIndexedY, cycles: 5}, cmp::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xE0, name: "CPX", bytes: 2, addressing_mode: AddressingModes::Immediate, cycles: 2}, cpx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xE4, name: "CPX", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, cpx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xEC, name: "CPX", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, cpx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xC0, name: "CPY", bytes: 2, addressing_mode: AddressingModes::Immediate, cycles: 2}, cpy::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xC4, name: "CPY", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, cpy::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xCC, name: "CPY", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, cpy::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xC6, name: "DEC", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 5}, dec::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xD6, name: "DEC", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 6}, dec::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xCE, name: "DEC", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 6}, dec::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xDE, name: "DEC", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 7}, dec::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xCA, name: "DEX", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, dex::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x88, name: "DEY", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, dey::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x49, name: "EOR", bytes: 2, addressing_mode: AddressingModes::Immediate, cycles: 2}, eor::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x45, name: "EOR", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, eor::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x55, name: "EOR", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 4}, eor::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x4D, name: "EOR", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, eor::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x5D, name: "EOR", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 4}, eor::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x59, name: "EOR", bytes: 3, addressing_mode: AddressingModes::AbsoluteY, cycles: 4}, eor::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x41, name: "EOR", bytes: 2, addressing_mode: AddressingModes::IndexedIndirectX, cycles: 6}, eor::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x51, name: "EOR", bytes: 2, addressing_mode: AddressingModes::IndirectIndexedY, cycles: 5}, eor::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xE6, name: "INC", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 5}, inc::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xF6, name: "INC", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 6}, inc::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xEE, name: "INC", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 6}, inc::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xFE, name: "INC", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 7}, inc::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xE8, name: "INX", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, inx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xC8, name: "INY", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, iny::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x4C, name: "JMP", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 3}, jmp::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x6C, name: "JMP", bytes: 5, addressing_mode: AddressingModes::Indirect, cycles: 5}, jmp::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x20, name: "JSR", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 6}, jsr::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xA9, name: "LDA", bytes: 2, addressing_mode: AddressingModes::Immediate, cycles: 2}, lda::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xA5, name: "LDA", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, lda::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xB5, name: "LDA", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 4}, lda::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xAD, name: "LDA", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, lda::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xBD, name: "LDA", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 4}, lda::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xB9, name: "LDA", bytes: 3, addressing_mode: AddressingModes::AbsoluteY, cycles: 4}, lda::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xA1, name: "LDA", bytes: 2, addressing_mode: AddressingModes::IndexedIndirectX, cycles: 6}, lda::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xB1, name: "LDA", bytes: 2, addressing_mode: AddressingModes::IndirectIndexedY, cycles: 5}, lda::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xA2, name: "LDX", bytes: 2, addressing_mode: AddressingModes::Immediate, cycles: 2}, ldx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xA6, name: "LDX", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, ldx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xB6, name: "LDX", bytes: 2, addressing_mode: AddressingModes::ZeroPageY, cycles: 4}, ldx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xAE, name: "LDX", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, ldx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xBE, name: "LDX", bytes: 3, addressing_mode: AddressingModes::AbsoluteY, cycles: 4}, ldx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xA0, name: "LDY", bytes: 2, addressing_mode: AddressingModes::Immediate, cycles: 2}, ldy::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xA4, name: "LDY", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, ldy::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xB4, name: "LDY", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 4}, ldy::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xAC, name: "LDY", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, ldy::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xBC, name: "LDY", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 4}, ldy::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x4A, name: "LSR", bytes: 1, addressing_mode: AddressingModes::Accumulator, cycles: 2}, lsr::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x46, name: "LSR", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 5}, lsr::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x56, name: "LSR", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 6}, lsr::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x4E, name: "LSR", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 6}, lsr::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x5E, name: "LSR", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 7}, lsr::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x1A, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x3A, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x5A, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x7A, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xDA, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xEA, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xFA, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x09, name: "ORA", bytes: 2, addressing_mode: AddressingModes::Immediate, cycles: 2}, ora::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x05, name: "ORA", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, ora::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x15, name: "ORA", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 4}, ora::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x0D, name: "ORA", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, ora::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x1D, name: "ORA", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 4}, ora::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x19, name: "ORA", bytes: 3, addressing_mode: AddressingModes::AbsoluteY, cycles: 4}, ora::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x01, name: "ORA", bytes: 2, addressing_mode: AddressingModes::IndexedIndirectX, cycles: 6}, ora::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x11, name: "ORA", bytes: 2, addressing_mode: AddressingModes::IndirectIndexedY, cycles: 5}, ora::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x48, name: "PHA", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 3}, pha::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x08, name: "PHP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 3}, php::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x68, name: "PLA", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 4}, pla::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x28, name: "PLP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 4}, plp::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x2A, name: "ROL", bytes: 1, addressing_mode: AddressingModes::Accumulator, cycles: 2}, rol::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x26, name: "ROL", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 5}, rol::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x36, name: "ROL", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 6}, rol::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x2E, name: "ROL", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 6}, rol::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x3E, name: "ROL", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 7}, rol::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x6A, name: "ROR", bytes: 1, addressing_mode: AddressingModes::Accumulator, cycles: 2}, ror::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x66, name: "ROR", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 5}, ror::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x76, name: "ROR", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 6}, ror::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x6E, name: "ROR", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 6}, ror::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x7E, name: "ROR", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 7}, ror::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x40, name: "RTI", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 6}, rti::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x60, name: "RTS", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 6}, rts::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xE9, name: "SBC", bytes: 2, addressing_mode: AddressingModes::Immediate, cycles: 2}, sbc::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xE5, name: "SBC", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, sbc::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xF5, name: "SBC", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 4}, sbc::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xED, name: "SBC", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, sbc::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xFD, name: "SBC", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 4}, sbc::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xF9, name: "SBC", bytes: 3, addressing_mode: AddressingModes::AbsoluteY, cycles: 4}, sbc::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xE1, name: "SBC", bytes: 2, addressing_mode: AddressingModes::IndexedIndirectX, cycles: 6}, sbc::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xF1, name: "SBC", bytes: 2, addressing_mode: AddressingModes::IndirectIndexedY, cycles: 5}, sbc::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x38, name: "SEC", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, sec::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xF8, name: "SED", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, sed::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x78, name: "SEI", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, sei::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x85, name: "STA", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x95, name: "STA", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 4}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x8D, name: "STA", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x9D, name: "STA", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 5}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x99, name: "STA", bytes: 3, addressing_mode: AddressingModes::AbsoluteY, cycles: 5}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x81, name: "STA", bytes: 2, addressing_mode: AddressingModes::IndexedIndirectX, cycles: 6}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x91, name: "STA", bytes: 2, addressing_mode: AddressingModes::IndirectIndexedY, cycles: 6}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x86, name: "STX", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, stx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x96, name: "STX", bytes: 2, addressing_mode: AddressingModes::ZeroPageY, cycles: 4}, stx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x8E, name: "STX", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, stx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x84, name: "STY", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, sty::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x94, name: "STY", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 4}, sty::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x8C, name: "STY", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, sty::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xAA, name: "TAX", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, tax::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xA8, name: "TAY", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, tay::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xBA, name: "TSX", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, tsx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x8A, name: "TXA", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, txa::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x9A, name: "TXS", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, txs::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x98, name: "TYA", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, tya::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xF8, name: "SED", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, sed::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xEA, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x00, name: "BRK", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 7}, brk::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xEA, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x1A, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x3A, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x5A, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x7A, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xDA, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xEA, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xFA, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x09, name: "ORA", bytes: 2, addressing_mode: AddressingModes::Immediate, cycles: 2}, ora::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x05, name: "ORA", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, ora::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x78, name: "SEI", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, sei::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x85, name: "STA", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x95, name: "STA", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 4}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x8D, name: "STA", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x9D, name: "STA", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 5}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x99, name: "STA", bytes: 3, addressing_mode: AddressingModes::AbsoluteY, cycles: 5}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x81, name: "STA", bytes: 2, addressing_mode: AddressingModes::IndexedIndirectX, cycles: 6}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x91, name: "STA", bytes: 2, addressing_mode: AddressingModes::IndirectIndexedY, cycles: 6}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x86, name: "STX", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, stx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x96, name: "STX", bytes: 2, addressing_mode: AddressingModes::ZeroPageY, cycles: 4}, stx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x8E, name: "STX", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, stx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x84, name: "STY", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, sty::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x94, name: "STY", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 4}, sty::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x8C, name: "STY", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, sty::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xAA, name: "TAX", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, tax::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x85, name: "STA", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x95, name: "STA", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 4}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x8D, name: "STA", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x9D, name: "STA", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 5}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x99, name: "STA", bytes: 3, addressing_mode: AddressingModes::AbsoluteY, cycles: 5}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x81, name: "STA", bytes: 2, addressing_mode: AddressingModes::IndexedIndirectX, cycles: 6}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x91, name: "STA", bytes: 2, addressing_mode: AddressingModes::IndirectIndexedY, cycles: 6}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x86, name: "STX", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, stx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x96, name: "STX", bytes: 2, addressing_mode: AddressingModes::ZeroPageY, cycles: 4}, stx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x8E, name: "STX", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, stx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x84, name: "STY", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, sty::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x94, name: "STY", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 4}, sty::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x8C, name: "STY", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, sty::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xAA, name: "TAX", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, tax::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xA8, name: "TAY", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, tay::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xBA, name: "TSX", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, tsx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x8A, name: "TXA", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, txa::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x9A, name: "TXS", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, txs::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x98, name: "TYA", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, tya::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x00, name: "BRK", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 7}, brk::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xEA, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x1A, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x3A, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x5A, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x7A, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xDA, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xEA, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xFA, name: "NOP", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, nop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x09, name: "ORA", bytes: 2, addressing_mode: AddressingModes::Immediate, cycles: 2}, ora::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x05, name: "ORA", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, ora::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x78, name: "SEI", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, sei::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x85, name: "STA", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x95, name: "STA", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 4}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x8D, name: "STA", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x9D, name: "STA", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 5}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x99, name: "STA", bytes: 3, addressing_mode: AddressingModes::AbsoluteY, cycles: 5}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x95, name: "STA", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 4}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x8D, name: "STA", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x9D, name: "STA", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 5}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x99, name: "STA", bytes: 3, addressing_mode: AddressingModes::AbsoluteY, cycles: 5}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x81, name: "STA", bytes: 2, addressing_mode: AddressingModes::IndexedIndirectX, cycles: 6}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x91, name: "STA", bytes: 2, addressing_mode: AddressingModes::IndirectIndexedY, cycles: 6}, sta::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x86, name: "STX", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, stx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x96, name: "STX", bytes: 2, addressing_mode: AddressingModes::ZeroPageY, cycles: 4}, stx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x8E, name: "STX", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, stx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x84, name: "STY", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, sty::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x94, name: "STY", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 4}, sty::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x8C, name: "STY", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, sty::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xAA, name: "TAX", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, tax::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xA8, name: "TAY", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, tay::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xBA, name: "TSX", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, tsx::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x8A, name: "TXA", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, txa::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x9A, name: "TXS", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, txs::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x98, name: "TYA", bytes: 1, addressing_mode: AddressingModes::Implicit, cycles: 2}, tya::<BasicMapper> as InstructionHandler<BasicMapper>),

        // Illegal Opcodes
        (Instruction {opcode: 0x0b, name: "AAC", bytes: 2, addressing_mode: AddressingModes::Immediate, cycles: 2}, aac::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x2b, name: "AAC", bytes: 2, addressing_mode: AddressingModes::Immediate, cycles: 2}, aac::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x04, name: "DOP", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, dop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x14, name: "DOP", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 4}, dop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x34, name: "DOP", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 4}, dop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x44, name: "DOP", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, dop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x54, name: "DOP", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 4}, dop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x64, name: "DOP", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 3}, dop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x74, name: "DOP", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 4}, dop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x80, name: "DOP", bytes: 2, addressing_mode: AddressingModes::Immediate, cycles: 2}, dop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x82, name: "DOP", bytes: 2, addressing_mode: AddressingModes::Immediate, cycles: 2}, dop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x89, name: "DOP", bytes: 2, addressing_mode: AddressingModes::Immediate, cycles: 2}, dop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xC2, name: "DOP", bytes: 2, addressing_mode: AddressingModes::Immediate, cycles: 2}, dop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xD4, name: "DOP", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 4}, dop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xE2, name: "DOP", bytes: 2, addressing_mode: AddressingModes::Immediate, cycles: 2}, dop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xF4, name: "DOP", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 4}, dop::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x27, name: "RLA", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 5}, rla::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x37, name: "RLA", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 6}, rla::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x2F, name: "RLA", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 6}, rla::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x3F, name: "RLA", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 7}, rla::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x3B, name: "RLA", bytes: 3, addressing_mode: AddressingModes::AbsoluteY, cycles: 7}, rla::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x23, name: "RLA", bytes: 2, addressing_mode: AddressingModes::IndexedIndirectX, cycles: 8}, rla::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x33, name: "RLA", bytes: 2, addressing_mode: AddressingModes::IndirectIndexedY, cycles: 8}, rla::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x07, name: "SLO", bytes: 2, addressing_mode: AddressingModes::ZeroPage, cycles: 5}, slo::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x17, name: "SLO", bytes: 2, addressing_mode: AddressingModes::ZeroPageX, cycles: 6}, slo::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x0F, name: "SLO", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 6}, slo::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x1F, name: "SLO", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 7}, slo::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x1B, name: "SLO", bytes: 3, addressing_mode: AddressingModes::AbsoluteY, cycles: 7}, slo::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x03, name: "SLO", bytes: 2, addressing_mode: AddressingModes::IndexedIndirectX, cycles: 8}, slo::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x13, name: "SLO", bytes: 2, addressing_mode: AddressingModes::IndirectIndexedY, cycles: 8}, slo::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x0C, name: "TOP", bytes: 3, addressing_mode: AddressingModes::Absolute, cycles: 4}, top::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x1C, name: "TOP", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 4}, top::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x3C, name: "TOP", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 4}, top::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x5C, name: "TOP", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 4}, top::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0x7C, name: "TOP", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 4}, top::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xDC, name: "TOP", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 4}, top::<BasicMapper> as InstructionHandler<BasicMapper>),
        (Instruction {opcode: 0xFC, name: "TOP", bytes: 3, addressing_mode: AddressingModes::AbsoluteX, cycles: 4}, top::<BasicMapper> as InstructionHandler<BasicMapper>),
        ]
    .into_iter()
    .collect()
});
pub static INSTRUCTIONS_TEST: Lazy<InstructionMap<TestMapper>> = Lazy::new(|| {
    vec![
        (
            Instruction {
                opcode: 0x69,
                name: "ADC",
                bytes: 2,
                addressing_mode: AddressingModes::Immediate,
                cycles: 2,
            },
            adc::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x65,
                name: "ADC",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            adc::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x75,
                name: "ADC",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 4,
            },
            adc::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x6D,
                name: "ADC",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            adc::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x7D,
                name: "ADC",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 4,
            },
            adc::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x79,
                name: "ADC",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteY,
                cycles: 4,
            },
            adc::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x61,
                name: "ADC",
                bytes: 2,
                addressing_mode: AddressingModes::IndexedIndirectX,
                cycles: 6,
            },
            adc::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x71,
                name: "ADC",
                bytes: 2,
                addressing_mode: AddressingModes::IndirectIndexedY,
                cycles: 5,
            },
            adc::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x29,
                name: "AND",
                bytes: 2,
                addressing_mode: AddressingModes::Immediate,
                cycles: 2,
            },
            and::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x25,
                name: "AND",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            and::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x35,
                name: "AND",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 4,
            },
            and::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x2D,
                name: "AND",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            and::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x3D,
                name: "AND",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 4,
            },
            and::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x39,
                name: "AND",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteY,
                cycles: 4,
            },
            and::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x21,
                name: "AND",
                bytes: 2,
                addressing_mode: AddressingModes::IndexedIndirectX,
                cycles: 6,
            },
            and::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x31,
                name: "AND",
                bytes: 2,
                addressing_mode: AddressingModes::IndirectIndexedY,
                cycles: 5,
            },
            and::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x0A,
                name: "ASL",
                bytes: 1,
                addressing_mode: AddressingModes::Accumulator,
                cycles: 2,
            },
            asl::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x06,
                name: "ASL",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 5,
            },
            asl::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x16,
                name: "ASL",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 6,
            },
            asl::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x0E,
                name: "ASL",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 6,
            },
            asl::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x1E,
                name: "ASL",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 7,
            },
            asl::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x90,
                name: "BCC",
                bytes: 2,
                addressing_mode: AddressingModes::Relative,
                cycles: 2,
            },
            bcc::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xB0,
                name: "BCS",
                bytes: 2,
                addressing_mode: AddressingModes::Relative,
                cycles: 2,
            },
            bcs::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xF0,
                name: "BEQ",
                bytes: 2,
                addressing_mode: AddressingModes::Relative,
                cycles: 2,
            },
            beq::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x24,
                name: "BIT",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            bit::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x2C,
                name: "BIT",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            bit::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x30,
                name: "BMI",
                bytes: 2,
                addressing_mode: AddressingModes::Relative,
                cycles: 2,
            },
            bmi::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xD0,
                name: "BNE",
                bytes: 2,
                addressing_mode: AddressingModes::Relative,
                cycles: 2,
            },
            bne::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x10,
                name: "BPL",
                bytes: 2,
                addressing_mode: AddressingModes::Relative,
                cycles: 2,
            },
            bpl::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x00,
                name: "BRK",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 7,
            },
            brk::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x50,
                name: "BVC",
                bytes: 2,
                addressing_mode: AddressingModes::Relative,
                cycles: 2,
            },
            bvc::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x70,
                name: "BVS",
                bytes: 2,
                addressing_mode: AddressingModes::Relative,
                cycles: 2,
            },
            bvs::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x18,
                name: "CLC",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            clc::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xD8,
                name: "CLD",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            cld::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x58,
                name: "CLI",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            cli::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xB8,
                name: "CLV",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            clv::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xC9,
                name: "CMP",
                bytes: 2,
                addressing_mode: AddressingModes::Immediate,
                cycles: 2,
            },
            cmp::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xC5,
                name: "CMP",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            cmp::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xD5,
                name: "CMP",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 4,
            },
            cmp::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xCD,
                name: "CMP",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            cmp::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xDD,
                name: "CMP",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 4,
            },
            cmp::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xD9,
                name: "CMP",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteY,
                cycles: 4,
            },
            cmp::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xC1,
                name: "CMP",
                bytes: 2,
                addressing_mode: AddressingModes::IndexedIndirectX,
                cycles: 6,
            },
            cmp::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xD1,
                name: "CMP",
                bytes: 2,
                addressing_mode: AddressingModes::IndirectIndexedY,
                cycles: 5,
            },
            cmp::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xE0,
                name: "CPX",
                bytes: 2,
                addressing_mode: AddressingModes::Immediate,
                cycles: 2,
            },
            cpx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xE4,
                name: "CPX",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            cpx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xEC,
                name: "CPX",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            cpx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xC0,
                name: "CPY",
                bytes: 2,
                addressing_mode: AddressingModes::Immediate,
                cycles: 2,
            },
            cpy::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xC4,
                name: "CPY",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            cpy::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xCC,
                name: "CPY",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            cpy::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xC6,
                name: "DEC",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 5,
            },
            dec::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xD6,
                name: "DEC",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 6,
            },
            dec::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xCE,
                name: "DEC",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 6,
            },
            dec::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xDE,
                name: "DEC",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 7,
            },
            dec::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xCA,
                name: "DEX",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            dex::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x88,
                name: "DEY",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            dey::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x49,
                name: "EOR",
                bytes: 2,
                addressing_mode: AddressingModes::Immediate,
                cycles: 2,
            },
            eor::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x45,
                name: "EOR",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            eor::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x55,
                name: "EOR",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 4,
            },
            eor::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x4D,
                name: "EOR",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            eor::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x5D,
                name: "EOR",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 4,
            },
            eor::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x59,
                name: "EOR",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteY,
                cycles: 4,
            },
            eor::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x41,
                name: "EOR",
                bytes: 2,
                addressing_mode: AddressingModes::IndexedIndirectX,
                cycles: 6,
            },
            eor::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x51,
                name: "EOR",
                bytes: 2,
                addressing_mode: AddressingModes::IndirectIndexedY,
                cycles: 5,
            },
            eor::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xE6,
                name: "INC",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 5,
            },
            inc::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xF6,
                name: "INC",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 6,
            },
            inc::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xEE,
                name: "INC",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 6,
            },
            inc::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xFE,
                name: "INC",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 7,
            },
            inc::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xE8,
                name: "INX",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            inx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xC8,
                name: "INY",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            iny::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x4C,
                name: "JMP",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 3,
            },
            jmp::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x6C,
                name: "JMP",
                bytes: 5,
                addressing_mode: AddressingModes::Indirect,
                cycles: 5,
            },
            jmp::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x20,
                name: "JSR",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 6,
            },
            jsr::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xA9,
                name: "LDA",
                bytes: 2,
                addressing_mode: AddressingModes::Immediate,
                cycles: 2,
            },
            lda::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xA5,
                name: "LDA",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            lda::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xB5,
                name: "LDA",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 4,
            },
            lda::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xAD,
                name: "LDA",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            lda::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xBD,
                name: "LDA",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 4,
            },
            lda::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xB9,
                name: "LDA",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteY,
                cycles: 4,
            },
            lda::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xA1,
                name: "LDA",
                bytes: 2,
                addressing_mode: AddressingModes::IndexedIndirectX,
                cycles: 6,
            },
            lda::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xB1,
                name: "LDA",
                bytes: 2,
                addressing_mode: AddressingModes::IndirectIndexedY,
                cycles: 5,
            },
            lda::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xA2,
                name: "LDX",
                bytes: 2,
                addressing_mode: AddressingModes::Immediate,
                cycles: 2,
            },
            ldx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xA6,
                name: "LDX",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            ldx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xB6,
                name: "LDX",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageY,
                cycles: 4,
            },
            ldx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xAE,
                name: "LDX",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            ldx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xBE,
                name: "LDX",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteY,
                cycles: 4,
            },
            ldx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xA0,
                name: "LDY",
                bytes: 2,
                addressing_mode: AddressingModes::Immediate,
                cycles: 2,
            },
            ldy::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xA4,
                name: "LDY",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            ldy::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xB4,
                name: "LDY",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 4,
            },
            ldy::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xAC,
                name: "LDY",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            ldy::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xBC,
                name: "LDY",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 4,
            },
            ldy::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x4A,
                name: "LSR",
                bytes: 1,
                addressing_mode: AddressingModes::Accumulator,
                cycles: 2,
            },
            lsr::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x46,
                name: "LSR",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 5,
            },
            lsr::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x56,
                name: "LSR",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 6,
            },
            lsr::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x4E,
                name: "LSR",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 6,
            },
            lsr::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x5E,
                name: "LSR",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 7,
            },
            lsr::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x1A,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x3A,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x5A,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x7A,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xDA,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xEA,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xFA,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x09,
                name: "ORA",
                bytes: 2,
                addressing_mode: AddressingModes::Immediate,
                cycles: 2,
            },
            ora::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x05,
                name: "ORA",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            ora::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x15,
                name: "ORA",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 4,
            },
            ora::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x0D,
                name: "ORA",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            ora::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x1D,
                name: "ORA",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 4,
            },
            ora::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x19,
                name: "ORA",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteY,
                cycles: 4,
            },
            ora::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x01,
                name: "ORA",
                bytes: 2,
                addressing_mode: AddressingModes::IndexedIndirectX,
                cycles: 6,
            },
            ora::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x11,
                name: "ORA",
                bytes: 2,
                addressing_mode: AddressingModes::IndirectIndexedY,
                cycles: 5,
            },
            ora::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x48,
                name: "PHA",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 3,
            },
            pha::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x08,
                name: "PHP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 3,
            },
            php::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x68,
                name: "PLA",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 4,
            },
            pla::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x28,
                name: "PLP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 4,
            },
            plp::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x2A,
                name: "ROL",
                bytes: 1,
                addressing_mode: AddressingModes::Accumulator,
                cycles: 2,
            },
            rol::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x26,
                name: "ROL",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 5,
            },
            rol::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x36,
                name: "ROL",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 6,
            },
            rol::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x2E,
                name: "ROL",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 6,
            },
            rol::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x3E,
                name: "ROL",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 7,
            },
            rol::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x6A,
                name: "ROR",
                bytes: 1,
                addressing_mode: AddressingModes::Accumulator,
                cycles: 2,
            },
            ror::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x66,
                name: "ROR",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 5,
            },
            ror::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x76,
                name: "ROR",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 6,
            },
            ror::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x6E,
                name: "ROR",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 6,
            },
            ror::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x7E,
                name: "ROR",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 7,
            },
            ror::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x40,
                name: "RTI",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 6,
            },
            rti::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x60,
                name: "RTS",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 6,
            },
            rts::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xE9,
                name: "SBC",
                bytes: 2,
                addressing_mode: AddressingModes::Immediate,
                cycles: 2,
            },
            sbc::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xE5,
                name: "SBC",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            sbc::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xF5,
                name: "SBC",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 4,
            },
            sbc::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xED,
                name: "SBC",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            sbc::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xFD,
                name: "SBC",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 4,
            },
            sbc::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xF9,
                name: "SBC",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteY,
                cycles: 4,
            },
            sbc::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xE1,
                name: "SBC",
                bytes: 2,
                addressing_mode: AddressingModes::IndexedIndirectX,
                cycles: 6,
            },
            sbc::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xF1,
                name: "SBC",
                bytes: 2,
                addressing_mode: AddressingModes::IndirectIndexedY,
                cycles: 5,
            },
            sbc::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x38,
                name: "SEC",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            sec::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xF8,
                name: "SED",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            sed::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x78,
                name: "SEI",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            sei::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x85,
                name: "STA",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x95,
                name: "STA",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 4,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x8D,
                name: "STA",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x9D,
                name: "STA",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 5,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x99,
                name: "STA",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteY,
                cycles: 5,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x81,
                name: "STA",
                bytes: 2,
                addressing_mode: AddressingModes::IndexedIndirectX,
                cycles: 6,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x91,
                name: "STA",
                bytes: 2,
                addressing_mode: AddressingModes::IndirectIndexedY,
                cycles: 6,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x86,
                name: "STX",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            stx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x96,
                name: "STX",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageY,
                cycles: 4,
            },
            stx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x8E,
                name: "STX",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            stx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x84,
                name: "STY",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            sty::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x94,
                name: "STY",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 4,
            },
            sty::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x8C,
                name: "STY",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            sty::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xAA,
                name: "TAX",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            tax::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xA8,
                name: "TAY",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            tay::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xBA,
                name: "TSX",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            tsx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x8A,
                name: "TXA",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            txa::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x9A,
                name: "TXS",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            txs::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x98,
                name: "TYA",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            tya::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xF8,
                name: "SED",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            sed::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xEA,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x00,
                name: "BRK",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 7,
            },
            brk::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xEA,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x1A,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x3A,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x5A,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x7A,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xDA,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xEA,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xFA,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x09,
                name: "ORA",
                bytes: 2,
                addressing_mode: AddressingModes::Immediate,
                cycles: 2,
            },
            ora::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x05,
                name: "ORA",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            ora::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x78,
                name: "SEI",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            sei::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x85,
                name: "STA",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x95,
                name: "STA",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 4,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x8D,
                name: "STA",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x9D,
                name: "STA",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 5,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x99,
                name: "STA",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteY,
                cycles: 5,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x81,
                name: "STA",
                bytes: 2,
                addressing_mode: AddressingModes::IndexedIndirectX,
                cycles: 6,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x91,
                name: "STA",
                bytes: 2,
                addressing_mode: AddressingModes::IndirectIndexedY,
                cycles: 6,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x86,
                name: "STX",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            stx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x96,
                name: "STX",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageY,
                cycles: 4,
            },
            stx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x8E,
                name: "STX",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            stx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x84,
                name: "STY",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            sty::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x94,
                name: "STY",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 4,
            },
            sty::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x8C,
                name: "STY",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            sty::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xAA,
                name: "TAX",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            tax::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x85,
                name: "STA",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x95,
                name: "STA",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 4,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x8D,
                name: "STA",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x9D,
                name: "STA",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 5,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x99,
                name: "STA",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteY,
                cycles: 5,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x81,
                name: "STA",
                bytes: 2,
                addressing_mode: AddressingModes::IndexedIndirectX,
                cycles: 6,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x91,
                name: "STA",
                bytes: 2,
                addressing_mode: AddressingModes::IndirectIndexedY,
                cycles: 6,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x86,
                name: "STX",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            stx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x96,
                name: "STX",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageY,
                cycles: 4,
            },
            stx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x8E,
                name: "STX",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            stx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x84,
                name: "STY",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            sty::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x94,
                name: "STY",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 4,
            },
            sty::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x8C,
                name: "STY",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            sty::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xAA,
                name: "TAX",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            tax::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xA8,
                name: "TAY",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            tay::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xBA,
                name: "TSX",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            tsx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x8A,
                name: "TXA",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            txa::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x9A,
                name: "TXS",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            txs::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x98,
                name: "TYA",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            tya::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x00,
                name: "BRK",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 7,
            },
            brk::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xEA,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x1A,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x3A,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x5A,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x7A,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xDA,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xEA,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xFA,
                name: "NOP",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            nop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x09,
                name: "ORA",
                bytes: 2,
                addressing_mode: AddressingModes::Immediate,
                cycles: 2,
            },
            ora::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x05,
                name: "ORA",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            ora::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x78,
                name: "SEI",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            sei::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x85,
                name: "STA",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x95,
                name: "STA",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 4,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x8D,
                name: "STA",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x9D,
                name: "STA",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 5,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x99,
                name: "STA",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteY,
                cycles: 5,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x95,
                name: "STA",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 4,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x8D,
                name: "STA",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x9D,
                name: "STA",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 5,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x99,
                name: "STA",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteY,
                cycles: 5,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x81,
                name: "STA",
                bytes: 2,
                addressing_mode: AddressingModes::IndexedIndirectX,
                cycles: 6,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x91,
                name: "STA",
                bytes: 2,
                addressing_mode: AddressingModes::IndirectIndexedY,
                cycles: 6,
            },
            sta::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x86,
                name: "STX",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            stx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x96,
                name: "STX",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageY,
                cycles: 4,
            },
            stx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x8E,
                name: "STX",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            stx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x84,
                name: "STY",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            sty::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x94,
                name: "STY",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 4,
            },
            sty::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x8C,
                name: "STY",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            sty::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xAA,
                name: "TAX",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            tax::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xA8,
                name: "TAY",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            tay::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xBA,
                name: "TSX",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            tsx::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x8A,
                name: "TXA",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            txa::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x9A,
                name: "TXS",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            txs::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x98,
                name: "TYA",
                bytes: 1,
                addressing_mode: AddressingModes::Implicit,
                cycles: 2,
            },
            tya::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        // Illegal Opcodes
        (
            Instruction {
                opcode: 0x0b,
                name: "AAC",
                bytes: 2,
                addressing_mode: AddressingModes::Immediate,
                cycles: 2,
            },
            aac::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x2b,
                name: "AAC",
                bytes: 2,
                addressing_mode: AddressingModes::Immediate,
                cycles: 2,
            },
            aac::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x04,
                name: "DOP",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            dop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x14,
                name: "DOP",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 4,
            },
            dop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x34,
                name: "DOP",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 4,
            },
            dop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x44,
                name: "DOP",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            dop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x54,
                name: "DOP",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 4,
            },
            dop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x64,
                name: "DOP",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 3,
            },
            dop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x74,
                name: "DOP",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 4,
            },
            dop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x80,
                name: "DOP",
                bytes: 2,
                addressing_mode: AddressingModes::Immediate,
                cycles: 2,
            },
            dop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x82,
                name: "DOP",
                bytes: 2,
                addressing_mode: AddressingModes::Immediate,
                cycles: 2,
            },
            dop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x89,
                name: "DOP",
                bytes: 2,
                addressing_mode: AddressingModes::Immediate,
                cycles: 2,
            },
            dop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xC2,
                name: "DOP",
                bytes: 2,
                addressing_mode: AddressingModes::Immediate,
                cycles: 2,
            },
            dop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xD4,
                name: "DOP",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 4,
            },
            dop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xE2,
                name: "DOP",
                bytes: 2,
                addressing_mode: AddressingModes::Immediate,
                cycles: 2,
            },
            dop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xF4,
                name: "DOP",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 4,
            },
            dop::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x27,
                name: "RLA",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 5,
            },
            rla::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x37,
                name: "RLA",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 6,
            },
            rla::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x2F,
                name: "RLA",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 6,
            },
            rla::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x3F,
                name: "RLA",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 7,
            },
            rla::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x3B,
                name: "RLA",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteY,
                cycles: 7,
            },
            rla::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x23,
                name: "RLA",
                bytes: 2,
                addressing_mode: AddressingModes::IndexedIndirectX,
                cycles: 8,
            },
            rla::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x33,
                name: "RLA",
                bytes: 2,
                addressing_mode: AddressingModes::IndirectIndexedY,
                cycles: 8,
            },
            rla::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x07,
                name: "SLO",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPage,
                cycles: 5,
            },
            slo::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x17,
                name: "SLO",
                bytes: 2,
                addressing_mode: AddressingModes::ZeroPageX,
                cycles: 6,
            },
            slo::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x0F,
                name: "SLO",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 6,
            },
            slo::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x1F,
                name: "SLO",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 7,
            },
            slo::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x1B,
                name: "SLO",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteY,
                cycles: 7,
            },
            slo::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x03,
                name: "SLO",
                bytes: 2,
                addressing_mode: AddressingModes::IndexedIndirectX,
                cycles: 8,
            },
            slo::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x13,
                name: "SLO",
                bytes: 2,
                addressing_mode: AddressingModes::IndirectIndexedY,
                cycles: 8,
            },
            slo::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x0C,
                name: "TOP",
                bytes: 3,
                addressing_mode: AddressingModes::Absolute,
                cycles: 4,
            },
            top::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x1C,
                name: "TOP",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 4,
            },
            top::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x3C,
                name: "TOP",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 4,
            },
            top::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x5C,
                name: "TOP",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 4,
            },
            top::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0x7C,
                name: "TOP",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 4,
            },
            top::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xDC,
                name: "TOP",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 4,
            },
            top::<TestMapper> as InstructionHandler<TestMapper>,
        ),
        (
            Instruction {
                opcode: 0xFC,
                name: "TOP",
                bytes: 3,
                addressing_mode: AddressingModes::AbsoluteX,
                cycles: 4,
            },
            top::<TestMapper> as InstructionHandler<TestMapper>,
        ),
    ]
    .into_iter()
    .collect()
});
#[derive(Clone, Copy)]
pub struct InstructionMap<M: Memory + 'static> {
    pub instructions: [Option<Instruction>; 256],
    pub instruction_handlers: [Option<InstructionHandler<M>>; 256],
}

impl<M: Memory + 'static> InstructionMap<M> {
    pub fn new() -> Self {
        Self {
            instructions: [const { None }; 256],
            instruction_handlers: [const { None }; 256],
        }
    }

    pub fn get_instruction(&self, opcode: u8) -> Option<Instruction> {
        self.instructions[opcode as usize].clone()
    }

    pub fn get_handler(&self, opcode: u8) -> Option<InstructionHandler<M>> {
        self.instruction_handlers[opcode as usize].clone()
    }
}

impl<M: Memory + 'static> FromIterator<(Instruction, InstructionHandler<M>)> for InstructionMap<M> {
    fn from_iter<T: IntoIterator<Item = (Instruction, InstructionHandler<M>)>>(iter: T) -> Self {
        let mut instruction_set = InstructionMap::new();
        for pair in iter {
            let opcode = pair.0.opcode;
            let instruction = pair.0;
            let instruction_handler = pair.1;
            instruction_set.instructions[opcode as usize] = Some(instruction);
            instruction_set.instruction_handlers[opcode as usize] = Some(instruction_handler);
        }
        instruction_set
    }
}

fn aac<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let operand = instruction.addressing_mode.get_operand(cpu);
    cpu.register_a = cpu.register_a & operand;
    cpu.update_zero_flag(cpu.register_a);
    cpu.update_negative_flag(cpu.register_a);
    match cpu.get_flag_state(STATUS_FLAG_NEGATIVE) {
        FlagStates::SET => {
            cpu.set_flag(STATUS_FLAG_CARRY);
        }
        FlagStates::CLEAR => {
            cpu.clear_flag(STATUS_FLAG_CARRY);
        }
    }
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}
fn adc<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let mut instruction_result = InstructionResult {
        executed_cycles: instruction.cycles,
    };
    let operand = instruction.addressing_mode.get_operand(cpu);
    let register_a_sign = cpu.register_a & 0b1000_0000;
    let operand_sign = operand & 0b1000_0000;
    let carry = cpu.get_flag_state(STATUS_FLAG_CARRY);
    let (temp_sum, overflow_occured_on_first_addition) = cpu.register_a.overflowing_add(operand);
    let (final_sum, overflow_occured_on_second_addition) = temp_sum.overflowing_add(carry as u8);
    cpu.register_a = final_sum;
    if overflow_occured_on_first_addition || overflow_occured_on_second_addition {
        cpu.set_flag(STATUS_FLAG_CARRY);
        cpu.set_flag(STATUS_FLAG_OVERFLOW);
    } else {
        cpu.clear_flag(STATUS_FLAG_CARRY)
    };

    let result_sign = cpu.register_a & 0b1000_0000;
    if register_a_sign == operand_sign && result_sign != register_a_sign {
        cpu.set_flag(STATUS_FLAG_OVERFLOW);
    } else {
        cpu.clear_flag(STATUS_FLAG_OVERFLOW);
    }

    cpu.update_negative_flag(cpu.register_a);
    cpu.update_zero_flag(cpu.register_a);
    instruction_result.executed_cycles += instruction.addressing_mode.is_page_crossed(cpu) as u8;
    return instruction_result;
}

fn and<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let mut instruction_result = InstructionResult {
        executed_cycles: instruction.cycles,
    };
    let operand = instruction.addressing_mode.get_operand(cpu);
    cpu.register_a = cpu.register_a & operand;
    cpu.update_zero_flag(cpu.register_a);
    cpu.update_negative_flag(cpu.register_a);
    instruction_result.executed_cycles += instruction.addressing_mode.is_page_crossed(cpu) as u8;
    return instruction_result;
}

fn asl<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    // code duplication, almost identical to lsr
    let instruction_result = InstructionResult {
        executed_cycles: instruction.cycles,
    };
    let operand = instruction.addressing_mode.get_operand(cpu);
    let operand_most_significant_bit = (operand & 0b1000_0000) >> 7;
    let result = operand << 1;

    match instruction.addressing_mode {
        AddressingModes::Accumulator => {
            cpu.register_a = result;
        }
        _ => {
            let operand_address = instruction.addressing_mode.get_operand_address(cpu);
            cpu.mapper.write_u8(operand_address, result);
        }
    }

    cpu.update_zero_flag(result);
    cpu.update_negative_flag(result);

    if operand_most_significant_bit == 1 {
        cpu.set_flag(STATUS_FLAG_CARRY);
    } else {
        cpu.clear_flag(STATUS_FLAG_CARRY);
    }
    return instruction_result;
}

fn bcc<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let mut instruction_result = InstructionResult {
        executed_cycles: instruction.cycles,
    };
    match cpu.get_flag_state(STATUS_FLAG_CARRY) {
        FlagStates::CLEAR => {
            let distance = cpu.mapper.read_u8(cpu.program_counter);
            let page_crossed = cpu.branch_off_program_counter(distance);
            instruction_result.executed_cycles += 1;
            instruction_result.executed_cycles += page_crossed as u8;
        }
        FlagStates::SET => (),
    }
    return instruction_result;
}

fn bcs<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let mut instruction_result = InstructionResult {
        executed_cycles: instruction.cycles,
    };
    match cpu.get_flag_state(STATUS_FLAG_CARRY) {
        FlagStates::SET => {
            let distance = cpu.mapper.read_u8(cpu.program_counter);
            let page_crossed = cpu.branch_off_program_counter(distance);
            instruction_result.executed_cycles += 1;
            instruction_result.executed_cycles += page_crossed as u8;
        }
        FlagStates::CLEAR => (),
    }
    return instruction_result;
}

fn beq<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let mut instruction_result = InstructionResult {
        executed_cycles: instruction.cycles,
    };
    match cpu.get_flag_state(STATUS_FLAG_ZERO) {
        FlagStates::SET => {
            let distance = cpu.mapper.read_u8(cpu.program_counter);
            let page_crossed = cpu.branch_off_program_counter(distance);
            instruction_result.executed_cycles += 1;
            instruction_result.executed_cycles += page_crossed as u8;
        }
        FlagStates::CLEAR => (),
    }
    return instruction_result;
}

fn bit<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let instruction_result = InstructionResult {
        executed_cycles: instruction.cycles,
    };
    let operand = instruction.addressing_mode.get_operand(cpu);
    let result = cpu.register_a & operand;

    cpu.update_zero_flag(result);
    cpu.update_negative_flag(operand);

    if operand & 0b0100_0000 == 0b0100_0000 {
        cpu.set_flag(STATUS_FLAG_OVERFLOW);
    } else {
        cpu.clear_flag(STATUS_FLAG_OVERFLOW);
    }
    return instruction_result;
}

fn bmi<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let mut instruction_result = InstructionResult {
        executed_cycles: instruction.cycles,
    };
    match cpu.get_flag_state(STATUS_FLAG_NEGATIVE) {
        FlagStates::SET => {
            let distance = cpu.mapper.read_u8(cpu.program_counter);
            let page_crossed = cpu.branch_off_program_counter(distance);
            instruction_result.executed_cycles += 1;
            instruction_result.executed_cycles += page_crossed as u8;
        }
        FlagStates::CLEAR => (),
    }
    return instruction_result;
}

fn bne<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let mut instruction_result = InstructionResult {
        executed_cycles: instruction.cycles,
    };
    match cpu.get_flag_state(STATUS_FLAG_ZERO) {
        FlagStates::CLEAR => {
            let distance = cpu.mapper.read_u8(cpu.program_counter);
            let page_crossed = cpu.branch_off_program_counter(distance);
            instruction_result.executed_cycles += 1;
            instruction_result.executed_cycles += page_crossed as u8;
        }
        FlagStates::SET => (),
    }
    return instruction_result;
}

fn bpl<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let mut instruction_result = InstructionResult {
        executed_cycles: instruction.cycles,
    };
    match cpu.get_flag_state(STATUS_FLAG_NEGATIVE) {
        FlagStates::CLEAR => {
            let distance = cpu.mapper.read_u8(cpu.program_counter);
            let page_crossed = cpu.branch_off_program_counter(distance);
            instruction_result.executed_cycles += 1;
            instruction_result.executed_cycles += page_crossed as u8;
        }
        FlagStates::SET => (),
    }
    return instruction_result;
}

fn bvc<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let mut instruction_result = InstructionResult {
        executed_cycles: instruction.cycles,
    };
    match cpu.get_flag_state(STATUS_FLAG_OVERFLOW) {
        FlagStates::CLEAR => {
            let distance = cpu.mapper.read_u8(cpu.program_counter);
            let page_crossed = cpu.branch_off_program_counter(distance);
            instruction_result.executed_cycles += 1;
            instruction_result.executed_cycles += page_crossed as u8;
        }
        FlagStates::SET => (),
    }
    return instruction_result;
}

fn bvs<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let mut instruction_result = InstructionResult {
        executed_cycles: instruction.cycles,
    };
    match cpu.get_flag_state(STATUS_FLAG_OVERFLOW) {
        FlagStates::SET => {
            let distance = cpu.mapper.read_u8(cpu.program_counter);
            let page_crossed = cpu.branch_off_program_counter(distance);
            instruction_result.executed_cycles += 1;
            instruction_result.executed_cycles += page_crossed as u8;
        }
        FlagStates::CLEAR => (),
    }
    return instruction_result;
}

fn brk<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let interrupt_vector = cpu.mapper.read_u16(0xFFFE);
    cpu.stack_push_u16(cpu.program_counter.wrapping_add(1));
    cpu.stack_push(cpu.status | 0b0001_0000);
    cpu.set_flag(STATUS_FLAG_INTERRUPT_DISABLE);
    cpu.program_counter = interrupt_vector;
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn clc<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.clear_flag(STATUS_FLAG_CARRY);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn cld<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.clear_flag(STATUS_FLAG_DECIMAL);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn cli<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.clear_flag(STATUS_FLAG_INTERRUPT_DISABLE);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}
fn clv<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.clear_flag(STATUS_FLAG_OVERFLOW);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn cmp<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let mut instruction_result = InstructionResult {
        executed_cycles: instruction.cycles,
    };
    let (result, overflow_occured) = cpu
        .register_a
        .overflowing_sub(instruction.addressing_mode.get_operand(cpu));

    if overflow_occured {
        cpu.clear_flag(STATUS_FLAG_CARRY);
    } else {
        cpu.set_flag(STATUS_FLAG_CARRY);
    }

    cpu.update_zero_flag(result);
    cpu.update_negative_flag(result);
    instruction_result.executed_cycles += instruction.addressing_mode.is_page_crossed(cpu) as u8;
    return instruction_result;
}

fn cpx<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    // todo: remove code duplication, almost similar to cmp, cpy
    let (result, overflow_occured) = cpu
        .register_x
        .overflowing_sub(instruction.addressing_mode.get_operand(cpu));

    if overflow_occured {
        cpu.clear_flag(STATUS_FLAG_CARRY);
    } else {
        cpu.set_flag(STATUS_FLAG_CARRY);
    }

    cpu.update_zero_flag(result);
    cpu.update_negative_flag(result);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn cpy<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    // todo: remove code duplication, almost similar to cmp, cpx
    let (result, overflow_occured) = cpu
        .register_y
        .overflowing_sub(instruction.addressing_mode.get_operand(cpu));

    if overflow_occured {
        cpu.clear_flag(STATUS_FLAG_CARRY);
    } else {
        cpu.set_flag(STATUS_FLAG_CARRY);
    }

    cpu.update_zero_flag(result);
    cpu.update_negative_flag(result);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn dec<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let address = instruction.addressing_mode.get_operand_address(cpu);
    let result = cpu.mapper.read_u8(address).wrapping_sub(1);
    cpu.mapper.write_u8(address, result);
    cpu.update_zero_flag(result);
    cpu.update_negative_flag(result);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn dex<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.register_x = cpu.register_x.wrapping_sub(1);
    cpu.update_zero_flag(cpu.register_x);
    cpu.update_negative_flag(cpu.register_x);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn dey<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.register_y = cpu.register_y.wrapping_sub(1);
    cpu.update_zero_flag(cpu.register_y);
    cpu.update_negative_flag(cpu.register_y);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn dop<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    nop(instruction, cpu);
    nop(instruction, cpu)
}

fn eor<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let mut instruction_result = InstructionResult {
        executed_cycles: instruction.cycles,
    };
    let operand = instruction.addressing_mode.get_operand(cpu);
    cpu.register_a = cpu.register_a ^ operand;
    cpu.update_zero_flag(cpu.register_a);
    cpu.update_negative_flag(cpu.register_a);
    instruction_result.executed_cycles += instruction.addressing_mode.is_page_crossed(cpu) as u8;
    return instruction_result;
}

fn lda<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let mut instruction_result = InstructionResult {
        executed_cycles: instruction.cycles,
    };
    // todo: remove duplicate code, same as ldx() and ldy()
    let operand = instruction.addressing_mode.get_operand(cpu);
    cpu.register_a = operand;
    cpu.update_zero_flag(cpu.register_a);
    cpu.update_negative_flag(cpu.register_a);
    instruction_result.executed_cycles += instruction.addressing_mode.is_page_crossed(cpu) as u8;
    return instruction_result;
}

fn ldx<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let mut instruction_result = InstructionResult {
        executed_cycles: instruction.cycles,
    };
    let operand = instruction.addressing_mode.get_operand(cpu);
    cpu.register_x = operand;
    cpu.update_zero_flag(cpu.register_x);
    cpu.update_negative_flag(cpu.register_x);
    instruction_result.executed_cycles += instruction.addressing_mode.is_page_crossed(cpu) as u8;
    return instruction_result;
}

fn ldy<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let mut instruction_result = InstructionResult {
        executed_cycles: instruction.cycles,
    };
    let operand = instruction.addressing_mode.get_operand(cpu);
    cpu.register_y = operand;
    cpu.update_zero_flag(cpu.register_y);
    cpu.update_negative_flag(cpu.register_y);
    instruction_result.executed_cycles += instruction.addressing_mode.is_page_crossed(cpu) as u8;
    return instruction_result;
}

fn lsr<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let operand = instruction.addressing_mode.get_operand(cpu);
    let operand_least_significant_bit = operand & 0b0000_0001;
    let result = operand >> 1;

    match instruction.addressing_mode {
        AddressingModes::Accumulator => {
            cpu.register_a = result;
        }
        _ => {
            let address = instruction.addressing_mode.get_operand_address(cpu);
            cpu.mapper.write_u8(address, result);
        }
    }

    cpu.update_zero_flag(result);
    cpu.update_negative_flag(result);

    if operand_least_significant_bit == 1 {
        cpu.set_flag(STATUS_FLAG_CARRY);
    } else {
        cpu.clear_flag(STATUS_FLAG_CARRY);
    }
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn ora<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let mut instruction_result = InstructionResult {
        executed_cycles: instruction.cycles,
    };
    let operand = instruction.addressing_mode.get_operand(cpu);
    cpu.register_a = cpu.register_a | operand;
    cpu.update_zero_flag(cpu.register_a);
    cpu.update_negative_flag(cpu.register_a);
    instruction_result.executed_cycles += instruction.addressing_mode.is_page_crossed(cpu) as u8;
    return instruction_result;
}

fn pha<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.stack_push(cpu.register_a);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn php<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.stack_push(cpu.status | 0b0001_0000);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn plp<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.status = cpu.stack_pop() | 0b0010_0000;
    // NesDev reference says that this flag should be set from stack,
    // but the test suite only passes if I clear it here.
    cpu.clear_flag(STATUS_FLAG_BREAK_COMMAND);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn pla<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.register_a = cpu.stack_pop();

    cpu.update_zero_flag(cpu.register_a);
    cpu.update_negative_flag(cpu.register_a);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn inc<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let address = instruction.addressing_mode.get_operand_address(cpu);
    let result = cpu.mapper.read_u8(address).wrapping_add(1);
    cpu.mapper.write_u8(address, result);
    cpu.update_zero_flag(result);
    cpu.update_negative_flag(result);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn inx<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.register_x = cpu.register_x.wrapping_add(1);
    cpu.update_zero_flag(cpu.register_x);
    cpu.update_negative_flag(cpu.register_x);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn iny<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.register_y = cpu.register_y.wrapping_add(1);
    cpu.update_zero_flag(cpu.register_y);
    cpu.update_negative_flag(cpu.register_y);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn rla<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    // Executes a rol followed by and
    let carry = cpu.get_flag_state(STATUS_FLAG_CARRY);

    let operand = instruction.addressing_mode.get_operand(cpu);
    let operand_most_significant_bit = (operand & 0b1000_0000) >> 7;
    let mut result = operand << 1;

    match carry {
        FlagStates::SET => {
            result = result | 0b0000_0001;
        }
        FlagStates::CLEAR => {
            result = result & 0b1111_1110;
        }
    }

    let address = instruction.addressing_mode.get_operand_address(cpu);
    cpu.mapper.write_u8(address, result);

    cpu.register_a = cpu.register_a & result;

    cpu.update_zero_flag(cpu.register_a);
    cpu.update_negative_flag(cpu.register_a);

    if operand_most_significant_bit == 1 {
        cpu.set_flag(STATUS_FLAG_CARRY);
    } else {
        cpu.clear_flag(STATUS_FLAG_CARRY);
    }

    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn rol<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let carry = cpu.get_flag_state(STATUS_FLAG_CARRY);

    let operand = instruction.addressing_mode.get_operand(cpu);
    let operand_most_significant_bit = (operand & 0b1000_0000) >> 7;
    let mut result = operand << 1;

    match carry {
        FlagStates::SET => {
            result = result | 0b0000_0001;
        }
        FlagStates::CLEAR => {
            result = result & 0b1111_1110;
        }
    }

    match instruction.addressing_mode {
        AddressingModes::Accumulator => {
            cpu.register_a = result;
        }
        _ => {
            let address = instruction.addressing_mode.get_operand_address(cpu);
            cpu.mapper.write_u8(address, result);
        }
    }

    cpu.update_zero_flag(result);
    cpu.update_negative_flag(result);

    if operand_most_significant_bit == 1 {
        cpu.set_flag(STATUS_FLAG_CARRY);
    } else {
        cpu.clear_flag(STATUS_FLAG_CARRY);
    }
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn ror<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let carry = cpu.get_flag_state(STATUS_FLAG_CARRY);

    let operand = instruction.addressing_mode.get_operand(cpu);
    let operand_least_significant_bit = operand & 0b0000_0001;
    let mut result = operand >> 1;

    match carry {
        FlagStates::SET => {
            result = result | 0b1000_0000;
        }
        FlagStates::CLEAR => {
            result = result & 0b0111_1111;
        }
    }

    match instruction.addressing_mode {
        AddressingModes::Accumulator => {
            cpu.register_a = result;
        }
        _ => {
            let address = instruction.addressing_mode.get_operand_address(cpu);
            cpu.mapper.write_u8(address, result);
        }
    }

    cpu.update_zero_flag(result);
    cpu.update_negative_flag(result);

    if operand_least_significant_bit == 1 {
        cpu.set_flag(STATUS_FLAG_CARRY);
    } else {
        cpu.clear_flag(STATUS_FLAG_CARRY);
    }
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn rti<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.status = cpu.stack_pop() | 0b0010_0000 & 0b1110_1111;
    cpu.program_counter = cpu.stack_pop_u16().wrapping_sub(1);
    cpu.clear_flag(STATUS_FLAG_BREAK_COMMAND);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}
fn rts<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.program_counter = cpu.stack_pop_u16();
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn nop<M: Memory + 'static>(instruction: &Instruction, _cpu: &mut CPU<M>) -> InstructionResult {
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}
fn jmp<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.program_counter = instruction.addressing_mode.get_operand_address(cpu);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn jsr<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    // Program counter is incremented instead of decremented as requested in the nesdev reference
    cpu.stack_push_u16(cpu.program_counter.wrapping_add(1));
    cpu.program_counter = instruction.addressing_mode.get_operand_address(cpu);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn sbc<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let mut instruction_result = InstructionResult {
        executed_cycles: instruction.cycles,
    };
    let operand = !instruction.addressing_mode.get_operand(cpu);
    let register_a_sign = cpu.register_a & 0b1000_0000;
    let operand_sign = operand & 0b1000_0000;
    let carry = cpu.get_flag_state(STATUS_FLAG_CARRY) as u8;
    let (temp_sum, overflow_occured_on_first_addition) = cpu.register_a.overflowing_add(operand);
    let (final_sum, overflow_occured_on_second_addition) = temp_sum.overflowing_add(carry);
    cpu.register_a = final_sum;
    if overflow_occured_on_first_addition || overflow_occured_on_second_addition {
        cpu.set_flag(STATUS_FLAG_CARRY);
        cpu.set_flag(STATUS_FLAG_OVERFLOW);
    } else {
        cpu.clear_flag(STATUS_FLAG_CARRY)
    };

    let result_sign = cpu.register_a & 0b1000_0000;
    if register_a_sign == operand_sign && result_sign != register_a_sign {
        cpu.set_flag(STATUS_FLAG_OVERFLOW);
    } else {
        cpu.clear_flag(STATUS_FLAG_OVERFLOW);
    }

    cpu.update_negative_flag(cpu.register_a);
    cpu.update_zero_flag(cpu.register_a);
    instruction_result.executed_cycles += instruction.addressing_mode.is_page_crossed(cpu) as u8;
    return instruction_result;
}

fn sec<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.set_flag(STATUS_FLAG_CARRY);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn sed<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.set_flag(STATUS_FLAG_DECIMAL);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn slo<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    // executes an asl followed by ora
    let operand = instruction.addressing_mode.get_operand(cpu);
    let operand_most_significant_bit = (operand & 0b1000_0000) >> 7;
    let result = operand << 1;

    match instruction.addressing_mode {
        AddressingModes::Accumulator => {
            cpu.register_a = result;
        }
        _ => {
            let operand_address = instruction.addressing_mode.get_operand_address(cpu);
            cpu.mapper.write_u8(operand_address, result);
        }
    }

    if operand_most_significant_bit == 1 {
        cpu.set_flag(STATUS_FLAG_CARRY);
    } else {
        cpu.clear_flag(STATUS_FLAG_CARRY);
    }

    cpu.register_a = cpu.register_a | result;
    cpu.update_zero_flag(cpu.register_a);
    cpu.update_negative_flag(cpu.register_a);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn sei<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.set_flag(STATUS_FLAG_INTERRUPT_DISABLE);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}
fn sta<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let address = instruction.addressing_mode.get_operand_address(cpu);
    cpu.mapper.write_u8(address, cpu.register_a);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn stx<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let address = instruction.addressing_mode.get_operand_address(cpu);
    cpu.mapper.write_u8(address, cpu.register_x);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}
fn sty<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let address = instruction.addressing_mode.get_operand_address(cpu);
    cpu.mapper.write_u8(address, cpu.register_y);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn tax<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.register_x = cpu.register_a;
    cpu.update_zero_flag(cpu.register_x);
    cpu.update_negative_flag(cpu.register_x);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn tay<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.register_y = cpu.register_a;

    cpu.update_zero_flag(cpu.register_y);
    cpu.update_negative_flag(cpu.register_y);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn top<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    let mut instruction_result = InstructionResult {
        executed_cycles: instruction.cycles,
    };

    instruction_result.executed_cycles += instruction.addressing_mode.is_page_crossed(cpu) as u8;
    nop(instruction, cpu);
    nop(instruction, cpu);
    nop(instruction, cpu);
    return instruction_result;
}

fn tsx<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.register_x = cpu.stack_pointer;
    cpu.update_zero_flag(cpu.register_x);
    cpu.update_negative_flag(cpu.register_x);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn txa<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.register_a = cpu.register_x;
    cpu.update_zero_flag(cpu.register_a);
    cpu.update_negative_flag(cpu.register_a);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn txs<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.stack_pointer = cpu.register_x;
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}

fn tya<M: Memory + 'static>(instruction: &Instruction, cpu: &mut CPU<M>) -> InstructionResult {
    cpu.register_a = cpu.register_y;
    cpu.update_zero_flag(cpu.register_a);
    cpu.update_negative_flag(cpu.register_a);
    return InstructionResult {
        executed_cycles: instruction.cycles,
    };
}
